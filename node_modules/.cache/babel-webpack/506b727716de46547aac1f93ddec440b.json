{"ast":null,"code":"/**\n * @module ol/source/VectorTile\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection } from '../tilegrid.js';\nimport { equals } from '../array.js';\nimport { fromKey, getKeyZXY } from '../tilecoord.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\n\nvar VectorTile =\n/** @class */\nfunction (_super) {\n  __extends(VectorTile, _super);\n  /**\n   * @param {!Options} options Vector tile options.\n   */\n\n\n  function VectorTile(options) {\n    var _this = this;\n\n    var projection = options.projection || 'EPSG:3857';\n    var extent = options.extent || extentFromProjection(projection);\n    var tileGrid = options.tileGrid || createXYZ({\n      extent: extent,\n      maxResolution: options.maxResolution,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize || 512\n    });\n    _this = _super.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      opaque: false,\n      projection: projection,\n      state: options.state,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX === undefined ? true : options.wrapX,\n      transition: options.transition,\n      zDirection: options.zDirection === undefined ? 1 : options.zDirection\n    }) || this;\n    /**\n     * @private\n     * @type {import(\"../format/Feature.js\").default}\n     */\n\n    _this.format_ = options.format ? options.format : null;\n    /**\n     * @type {Object<string, import(\"./VectorTile\").default>}\n     */\n\n    _this.loadingTiles_ = {};\n    /**\n     * @private\n     * @type {TileCache}\n     */\n\n    _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @protected\n     * @type {typeof import(\"../VectorTile.js\").default}\n     */\n\n    _this.tileClass = options.tileClass ? options.tileClass : Tile;\n    /**\n     * @private\n     * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n\n    _this.tileGrids_ = {};\n    return _this;\n  }\n  /**\n   * Get features whose bounding box intersects the provided extent. Only features for cached\n   * tiles for the last rendered zoom level are available in the source. So this method is only\n   * suitable for requesting tiles for extents that are currently rendered.\n   *\n   * Features are returned in random tile order and as they are included in the tiles. This means\n   * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n   *\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n   * @api\n   */\n\n\n  VectorTile.prototype.getFeaturesInExtent = function (extent) {\n    var features = [];\n    var tileCache = this.tileCache;\n\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n\n    var z = fromKey(tileCache.peekFirstKey())[0];\n    var tileGrid = this.tileGrid;\n    tileCache.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n\n      var sourceTiles = tile.getSourceTiles();\n\n      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        var sourceTile = sourceTiles[i];\n        var tileCoord = sourceTile.tileCoord;\n\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          var tileFeatures = sourceTile.getFeatures();\n\n          if (tileFeatures) {\n            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              var candidate = tileFeatures[j];\n              var geometry = candidate.getGeometry();\n\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  VectorTile.prototype.getOverlaps = function () {\n    return this.overlaps_;\n  };\n  /**\n   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n   * @api\n   */\n\n\n  VectorTile.prototype.clear = function () {\n    this.tileCache.clear();\n    this.sourceTileCache.clear();\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   */\n\n\n  VectorTile.prototype.expireCache = function (projection, usedTiles) {\n    _super.prototype.expireCache.call(this, projection, usedTiles);\n\n    this.sourceTileCache.expireCache({});\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection\").default} projection Projection.\n   * @param {VectorRenderTile} tile Vector image tile.\n   * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n   */\n\n\n  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n    var urlTileCoord = tile.wrappedTileCoord;\n    var tileGrid = this.getTileGridForProjection(projection);\n    var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n    var z = urlTileCoord[0];\n    var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n    bufferExtent(extent, -resolution, extent);\n    var sourceTileGrid = this.tileGrid;\n    var sourceExtent = sourceTileGrid.getExtent();\n\n    if (sourceExtent) {\n      getIntersection(extent, sourceExtent, extent);\n    }\n\n    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n    var minZoom = sourceTileGrid.getMinZoom();\n    var previousSourceTiles = tile.sourceTiles;\n    var sourceTiles, covered, loadedZ;\n\n    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {\n      sourceTiles = previousSourceTiles;\n      covered = true;\n      loadedZ = sourceZ;\n    } else {\n      sourceTiles = [];\n      loadedZ = sourceZ + 1;\n\n      do {\n        --loadedZ;\n        covered = true;\n        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n          var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n          var sourceTile;\n\n          if (tileUrl !== undefined) {\n            if (this.sourceTileCache.containsKey(tileUrl)) {\n              sourceTile = this.sourceTileCache.get(tileUrl);\n              var state = sourceTile.getState();\n\n              if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {\n                sourceTiles.push(sourceTile);\n                return;\n              }\n            } else if (loadedZ === sourceZ) {\n              sourceTile = new this.tileClass(sourceTileCoord, TileState.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n              sourceTile.projection = projection;\n              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n              this.sourceTileCache.set(tileUrl, sourceTile);\n              sourceTile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n              sourceTile.load();\n            }\n          }\n\n          covered = covered && sourceTile && sourceTile.getState() === TileState.LOADED;\n\n          if (!sourceTile) {\n            return;\n          }\n\n          if (sourceTile.getState() !== TileState.EMPTY && tile.getState() === TileState.IDLE) {\n            tile.loadingSourceTiles++;\n            sourceTile.addEventListener(EventType.CHANGE, function listenChange() {\n              var state = sourceTile.getState();\n              var sourceTileKey = sourceTile.getKey();\n\n              if (state === TileState.LOADED || state === TileState.ERROR) {\n                if (state === TileState.LOADED) {\n                  sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n                  tile.loadingSourceTiles--;\n                  delete tile.errorSourceTileKeys[sourceTileKey];\n                } else if (state === TileState.ERROR) {\n                  tile.errorSourceTileKeys[sourceTileKey] = true;\n                }\n\n                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;\n\n                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                  tile.hifi = errorTileCount === 0;\n                  tile.sourceZ = sourceZ;\n                  tile.setState(TileState.LOADED);\n                }\n              }\n            });\n          }\n        }.bind(this));\n\n        if (!covered) {\n          sourceTiles.length = 0;\n        }\n      } while (!covered && loadedZ > minZoom);\n    }\n\n    if (tile.getState() === TileState.IDLE) {\n      tile.setState(TileState.LOADING);\n    }\n\n    if (covered) {\n      tile.hifi = sourceZ === loadedZ;\n      tile.sourceZ = loadedZ;\n\n      if (tile.getState() < TileState.LOADED) {\n        tile.setState(TileState.LOADED);\n      } else if (!previousSourceTiles || !equals(sourceTiles, previousSourceTiles)) {\n        tile.sourceTiles = sourceTiles;\n      }\n    }\n\n    return sourceTiles;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!VectorRenderTile} Tile.\n   */\n\n\n  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n    var coordKey = getKeyZXY(z, x, y);\n    var key = this.getKey();\n    var tile;\n\n    if (this.tileCache.containsKey(coordKey)) {\n      tile = this.tileCache.get(coordKey);\n\n      if (tile.key === key) {\n        return tile;\n      }\n    }\n\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var sourceExtent = this.getTileGrid().getExtent();\n    var tileGrid = this.getTileGridForProjection(projection);\n\n    if (urlTileCoord && sourceExtent) {\n      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n\n      if (!intersects(sourceExtent, tileExtent)) {\n        urlTileCoord = null;\n      }\n    }\n\n    var empty = true;\n\n    if (urlTileCoord !== null) {\n      var sourceTileGrid = this.tileGrid;\n      var resolution = tileGrid.getResolution(z);\n      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n\n      var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n      bufferExtent(extent, -resolution, extent);\n      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n      }.bind(this));\n    }\n\n    var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n    newTile.key = key;\n\n    if (tile) {\n      newTile.interimTile = tile;\n      newTile.refreshInterimChain();\n      this.tileCache.replace(coordKey, newTile);\n    } else {\n      this.tileCache.set(coordKey, newTile);\n    }\n\n    return newTile;\n  };\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   */\n\n\n  VectorTile.prototype.getTileGridForProjection = function (projection) {\n    var code = projection.getCode();\n    var tileGrid = this.tileGrids_[code];\n\n    if (!tileGrid) {\n      // A tile grid that matches the tile size of the source tile grid is more\n      // likely to have 1:1 relationships between source tiles and rendered tiles.\n      var sourceTileGrid = this.tileGrid;\n      tileGrid = createForProjection(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);\n      this.tileGrids_[code] = tileGrid;\n    }\n\n    return tileGrid;\n  };\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n    return pixelRatio;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../size.js\").Size} Tile size.\n   */\n\n\n  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];\n  };\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n\n\n  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n  };\n\n  return VectorTile;\n}(UrlTile);\n\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\n\nexport function defaultLoadFunction(tile, url) {\n  tile.setLoader(\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  function (extent, resolution, projection) {\n    loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n  });\n} //# sourceMappingURL=VectorTile.js.map","map":{"version":3,"sources":["D:/angular-openlayer/node_modules/ol/source/VectorTile.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__","constructor","create","EventType","Tile","TileCache","TileState","UrlTile","VectorRenderTile","buffer","bufferExtent","getIntersection","intersects","createForProjection","createXYZ","extentFromProjection","equals","fromKey","getKeyZXY","loadFeaturesXhr","toSize","VectorTile","_super","options","_this","projection","extent","tileGrid","maxResolution","maxZoom","undefined","minZoom","tileSize","attributions","attributionsCollapsible","cacheSize","opaque","state","tileLoadFunction","defaultLoadFunction","tileUrlFunction","url","urls","wrapX","transition","zDirection","format_","format","loadingTiles_","sourceTileCache","tileCache","highWaterMark","overlaps_","overlaps","tileClass","tileGrids_","getFeaturesInExtent","features","getCount","z","peekFirstKey","forEach","tile","tileCoord","getState","LOADED","sourceTiles","getSourceTiles","i","ii","length","sourceTile","getTileCoordExtent","tileFeatures","getFeatures","j","jj","candidate","geometry","getGeometry","getExtent","push","getOverlaps","clear","expireCache","usedTiles","pixelRatio","urlTileCoord","wrappedTileCoord","getTileGridForProjection","resolution","getResolution","sourceTileGrid","sourceExtent","sourceZ","getZForResolution","getMinZoom","previousSourceTiles","covered","loadedZ","forEachTileCoord","sourceTileCoord","tileUrl","containsKey","get","ERROR","EMPTY","IDLE","set","addEventListener","CHANGE","handleTileChange","bind","load","loadingSourceTiles","listenChange","sourceTileKey","getKey","removeEventListener","errorSourceTileKeys","errorTileCount","keys","hifi","setState","LOADING","getTile","x","y","coordKey","key","getTileCoordForTileUrlFunction","getTileGrid","tileExtent","empty","newTile","interimTile","refreshInterimChain","replace","code","getCode","getTileSize","getTilePixelRatio","getTilePixelSize","tmpSize","Math","round","updateCacheSize","tileCount","setLoader","getFormat","onLoad","onError"],"mappings":"AAAA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIC,MAAM,CAACK,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCR,CAArC,EAAwCK,CAAxC,CAAJ,EAAgDN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAFrG;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASS,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBX,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACO,SAAF,GAAcN,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACU,MAAP,CAAcX,CAAd,CAAb,IAAiCS,EAAE,CAACH,SAAH,GAAeN,CAAC,CAACM,SAAjB,EAA4B,IAAIG,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,OAAOG,SAAP,MAAsB,wBAAtB;AACA,OAAOC,IAAP,MAAiB,kBAAjB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,OAAOC,OAAP,MAAoB,cAApB;AACA,OAAOC,gBAAP,MAA6B,wBAA7B;AACA,SAASC,MAAM,IAAIC,YAAnB,EAAiCC,eAAjC,EAAkDC,UAAlD,QAAqE,cAArE;AACA,SAASC,mBAAT,EAA8BC,SAA9B,EAAyCC,oBAAzC,QAAsE,gBAAtE;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,OAAT,EAAkBC,SAAlB,QAAmC,iBAAnC;AACA,SAASC,eAAT,QAAgC,qBAAhC;AACA,SAASC,MAAT,QAAuB,YAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,UAAU;AAAG;AAAe,UAAUC,MAAV,EAAkB;AAC9ClC,EAAAA,SAAS,CAACiC,UAAD,EAAaC,MAAb,CAAT;AACA;AACJ;AACA;;;AACI,WAASD,UAAT,CAAoBE,OAApB,EAA6B;AACzB,QAAIC,KAAK,GAAG,IAAZ;;AACA,QAAIC,UAAU,GAAGF,OAAO,CAACE,UAAR,IAAsB,WAAvC;AACA,QAAIC,MAAM,GAAGH,OAAO,CAACG,MAAR,IAAkBX,oBAAoB,CAACU,UAAD,CAAnD;AACA,QAAIE,QAAQ,GAAGJ,OAAO,CAACI,QAAR,IACXb,SAAS,CAAC;AACNY,MAAAA,MAAM,EAAEA,MADF;AAENE,MAAAA,aAAa,EAAEL,OAAO,CAACK,aAFjB;AAGNC,MAAAA,OAAO,EAAEN,OAAO,CAACM,OAAR,KAAoBC,SAApB,GAAgCP,OAAO,CAACM,OAAxC,GAAkD,EAHrD;AAINE,MAAAA,OAAO,EAAER,OAAO,CAACQ,OAJX;AAKNC,MAAAA,QAAQ,EAAET,OAAO,CAACS,QAAR,IAAoB;AALxB,KAAD,CADb;AAQAR,IAAAA,KAAK,GAAGF,MAAM,CAACvB,IAAP,CAAY,IAAZ,EAAkB;AACtBkC,MAAAA,YAAY,EAAEV,OAAO,CAACU,YADA;A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","sourcesContent":["/**\n * @module ol/source/VectorTile\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport EventType from '../events/EventType.js';\nimport Tile from '../VectorTile.js';\nimport TileCache from '../TileCache.js';\nimport TileState from '../TileState.js';\nimport UrlTile from './UrlTile.js';\nimport VectorRenderTile from '../VectorRenderTile.js';\nimport { buffer as bufferExtent, getIntersection, intersects, } from '../extent.js';\nimport { createForProjection, createXYZ, extentFromProjection, } from '../tilegrid.js';\nimport { equals } from '../array.js';\nimport { fromKey, getKeyZXY } from '../tilecoord.js';\nimport { loadFeaturesXhr } from '../featureloader.js';\nimport { toSize } from '../size.js';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.\n * @property {import(\"../extent.js\").Extent} [extent]\n * @property {import(\"../format/Feature.js\").default} [format] Feature format for tiles. Used and required by the default.\n * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this\n * to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.\n * @property {import(\"./State.js\").default} [state] Source state.\n * @property {typeof import(\"../VectorTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/VectorTile}.\n * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. Could look like this for pbf tiles:\n * ```js\n * function(tile, url) {\n *   tile.setLoader(function(extent, resolution, projection) {\n *     fetch(url).then(function(response) {\n *       response.arrayBuffer().then(function(data) {\n *         const format = tile.getFormat() // ol/format/MVT configured as source format\n *         const features = format.readFeatures(data, {\n *           extent: extent,\n *           featureProjection: projection\n *         });\n *         tile.setFeatures(features);\n *       });\n *     });\n *   });\n * }\n * ```\n * If you do not need extent, resolution and projection to get the features for a tile (e.g.\n * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure\n * to call `setFeatures()` on the tile:\n * ```js\n * const format = new GeoJSON({featureProjection: map.getView().getProjection()});\n * async function tileLoadFunction(tile, url) {\n *   const response = await fetch(url);\n *   const data = await response.json();\n *   tile.setFeatures(format.readFeatures(data));\n * }\n * ```\n * @property {import(\"../Tile.js\").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {number} [transition] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When set to `true`, tiles will be wrapped horizontally to\n * render multiple worlds.\n * @property {number} [zDirection=1] Indicate which resolution should be used\n * by a renderer if the view resolution does not match any resolution of the tile source.\n * If 0, the nearest resolution will be used. If 1, the nearest lower resolution\n * will be used. If -1, the nearest higher resolution will be used.\n */\n/**\n * @classdesc\n * Class for layer sources providing vector data divided into a tile grid, to be\n * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles\n * with vector features from the server, it is not meant for feature editing.\n * Features are optimized for rendering, their geometries are clipped at or near\n * tile boundaries and simplified for a view resolution. See\n * {@link module:ol/source/Vector} for vector sources that are suitable for feature\n * editing.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @api\n */\nvar VectorTile = /** @class */ (function (_super) {\n    __extends(VectorTile, _super);\n    /**\n     * @param {!Options} options Vector tile options.\n     */\n    function VectorTile(options) {\n        var _this = this;\n        var projection = options.projection || 'EPSG:3857';\n        var extent = options.extent || extentFromProjection(projection);\n        var tileGrid = options.tileGrid ||\n            createXYZ({\n                extent: extent,\n                maxResolution: options.maxResolution,\n                maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,\n                minZoom: options.minZoom,\n                tileSize: options.tileSize || 512,\n            });\n        _this = _super.call(this, {\n            attributions: options.attributions,\n            attributionsCollapsible: options.attributionsCollapsible,\n            cacheSize: options.cacheSize,\n            opaque: false,\n            projection: projection,\n            state: options.state,\n            tileGrid: tileGrid,\n            tileLoadFunction: options.tileLoadFunction\n                ? options.tileLoadFunction\n                : defaultLoadFunction,\n            tileUrlFunction: options.tileUrlFunction,\n            url: options.url,\n            urls: options.urls,\n            wrapX: options.wrapX === undefined ? true : options.wrapX,\n            transition: options.transition,\n            zDirection: options.zDirection === undefined ? 1 : options.zDirection,\n        }) || this;\n        /**\n         * @private\n         * @type {import(\"../format/Feature.js\").default}\n         */\n        _this.format_ = options.format ? options.format : null;\n        /**\n         * @type {Object<string, import(\"./VectorTile\").default>}\n         */\n        _this.loadingTiles_ = {};\n        /**\n         * @private\n         * @type {TileCache}\n         */\n        _this.sourceTileCache = new TileCache(_this.tileCache.highWaterMark);\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n        /**\n         * @protected\n         * @type {typeof import(\"../VectorTile.js\").default}\n         */\n        _this.tileClass = options.tileClass ? options.tileClass : Tile;\n        /**\n         * @private\n         * @type {Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n         */\n        _this.tileGrids_ = {};\n        return _this;\n    }\n    /**\n     * Get features whose bounding box intersects the provided extent. Only features for cached\n     * tiles for the last rendered zoom level are available in the source. So this method is only\n     * suitable for requesting tiles for extents that are currently rendered.\n     *\n     * Features are returned in random tile order and as they are included in the tiles. This means\n     * they can be clipped, duplicated across tiles, and simplified to the render resolution.\n     *\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     * @api\n     */\n    VectorTile.prototype.getFeaturesInExtent = function (extent) {\n        var features = [];\n        var tileCache = this.tileCache;\n        if (tileCache.getCount() === 0) {\n            return features;\n        }\n        var z = fromKey(tileCache.peekFirstKey())[0];\n        var tileGrid = this.tileGrid;\n        tileCache.forEach(function (tile) {\n            if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n                return;\n            }\n            var sourceTiles = tile.getSourceTiles();\n            for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {\n                var sourceTile = sourceTiles[i];\n                var tileCoord = sourceTile.tileCoord;\n                if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n                    var tileFeatures = sourceTile.getFeatures();\n                    if (tileFeatures) {\n                        for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {\n                            var candidate = tileFeatures[j];\n                            var geometry = candidate.getGeometry();\n                            if (intersects(extent, geometry.getExtent())) {\n                                features.push(candidate);\n                            }\n                        }\n                    }\n                }\n            }\n        });\n        return features;\n    };\n    /**\n     * @return {boolean} The source can have overlapping geometries.\n     */\n    VectorTile.prototype.getOverlaps = function () {\n        return this.overlaps_;\n    };\n    /**\n     * clear {@link module:ol/TileCache~TileCache} and delete all source tiles\n     * @api\n     */\n    VectorTile.prototype.clear = function () {\n        this.tileCache.clear();\n        this.sourceTileCache.clear();\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @param {!Object<string, boolean>} usedTiles Used tiles.\n     */\n    VectorTile.prototype.expireCache = function (projection, usedTiles) {\n        _super.prototype.expireCache.call(this, projection, usedTiles);\n        this.sourceTileCache.expireCache({});\n    };\n    /**\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection\").default} projection Projection.\n     * @param {VectorRenderTile} tile Vector image tile.\n     * @return {Array<import(\"../VectorTile\").default>} Tile keys.\n     */\n    VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {\n        var urlTileCoord = tile.wrappedTileCoord;\n        var tileGrid = this.getTileGridForProjection(projection);\n        var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n        var z = urlTileCoord[0];\n        var resolution = tileGrid.getResolution(z);\n        // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n        bufferExtent(extent, -resolution, extent);\n        var sourceTileGrid = this.tileGrid;\n        var sourceExtent = sourceTileGrid.getExtent();\n        if (sourceExtent) {\n            getIntersection(extent, sourceExtent, extent);\n        }\n        var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n        var minZoom = sourceTileGrid.getMinZoom();\n        var previousSourceTiles = tile.sourceTiles;\n        var sourceTiles, covered, loadedZ;\n        if (previousSourceTiles &&\n            previousSourceTiles.length > 0 &&\n            previousSourceTiles[0].tileCoord[0] === sourceZ) {\n            sourceTiles = previousSourceTiles;\n            covered = true;\n            loadedZ = sourceZ;\n        }\n        else {\n            sourceTiles = [];\n            loadedZ = sourceZ + 1;\n            do {\n                --loadedZ;\n                covered = true;\n                sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {\n                    var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n                    var sourceTile;\n                    if (tileUrl !== undefined) {\n                        if (this.sourceTileCache.containsKey(tileUrl)) {\n                            sourceTile = this.sourceTileCache.get(tileUrl);\n                            var state = sourceTile.getState();\n                            if (state === TileState.LOADED ||\n                                state === TileState.ERROR ||\n                                state === TileState.EMPTY) {\n                                sourceTiles.push(sourceTile);\n                                return;\n                            }\n                        }\n                        else if (loadedZ === sourceZ) {\n                            sourceTile = new this.tileClass(sourceTileCoord, TileState.IDLE, tileUrl, this.format_, this.tileLoadFunction);\n                            sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n                            sourceTile.projection = projection;\n                            sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);\n                            this.sourceTileCache.set(tileUrl, sourceTile);\n                            sourceTile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));\n                            sourceTile.load();\n                        }\n                    }\n                    covered =\n                        covered &&\n                            sourceTile &&\n                            sourceTile.getState() === TileState.LOADED;\n                    if (!sourceTile) {\n                        return;\n                    }\n                    if (sourceTile.getState() !== TileState.EMPTY &&\n                        tile.getState() === TileState.IDLE) {\n                        tile.loadingSourceTiles++;\n                        sourceTile.addEventListener(EventType.CHANGE, function listenChange() {\n                            var state = sourceTile.getState();\n                            var sourceTileKey = sourceTile.getKey();\n                            if (state === TileState.LOADED || state === TileState.ERROR) {\n                                if (state === TileState.LOADED) {\n                                    sourceTile.removeEventListener(EventType.CHANGE, listenChange);\n                                    tile.loadingSourceTiles--;\n                                    delete tile.errorSourceTileKeys[sourceTileKey];\n                                }\n                                else if (state === TileState.ERROR) {\n                                    tile.errorSourceTileKeys[sourceTileKey] = true;\n                                }\n                                var errorTileCount = Object.keys(tile.errorSourceTileKeys)\n                                    .length;\n                                if (tile.loadingSourceTiles - errorTileCount === 0) {\n                                    tile.hifi = errorTileCount === 0;\n                                    tile.sourceZ = sourceZ;\n                                    tile.setState(TileState.LOADED);\n                                }\n                            }\n                        });\n                    }\n                }.bind(this));\n                if (!covered) {\n                    sourceTiles.length = 0;\n                }\n            } while (!covered && loadedZ > minZoom);\n        }\n        if (tile.getState() === TileState.IDLE) {\n            tile.setState(TileState.LOADING);\n        }\n        if (covered) {\n            tile.hifi = sourceZ === loadedZ;\n            tile.sourceZ = loadedZ;\n            if (tile.getState() < TileState.LOADED) {\n                tile.setState(TileState.LOADED);\n            }\n            else if (!previousSourceTiles ||\n                !equals(sourceTiles, previousSourceTiles)) {\n                tile.sourceTiles = sourceTiles;\n            }\n        }\n        return sourceTiles;\n    };\n    /**\n     * @param {number} z Tile coordinate z.\n     * @param {number} x Tile coordinate x.\n     * @param {number} y Tile coordinate y.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!VectorRenderTile} Tile.\n     */\n    VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {\n        var coordKey = getKeyZXY(z, x, y);\n        var key = this.getKey();\n        var tile;\n        if (this.tileCache.containsKey(coordKey)) {\n            tile = this.tileCache.get(coordKey);\n            if (tile.key === key) {\n                return tile;\n            }\n        }\n        var tileCoord = [z, x, y];\n        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var sourceExtent = this.getTileGrid().getExtent();\n        var tileGrid = this.getTileGridForProjection(projection);\n        if (urlTileCoord && sourceExtent) {\n            var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            bufferExtent(tileExtent, -tileGrid.getResolution(z), tileExtent);\n            if (!intersects(sourceExtent, tileExtent)) {\n                urlTileCoord = null;\n            }\n        }\n        var empty = true;\n        if (urlTileCoord !== null) {\n            var sourceTileGrid = this.tileGrid;\n            var resolution = tileGrid.getResolution(z);\n            var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);\n            // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space\n            var extent = tileGrid.getTileCoordExtent(urlTileCoord);\n            bufferExtent(extent, -resolution, extent);\n            sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {\n                empty =\n                    empty &&\n                        !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);\n            }.bind(this));\n        }\n        var newTile = new VectorRenderTile(tileCoord, empty ? TileState.EMPTY : TileState.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));\n        newTile.key = key;\n        if (tile) {\n            newTile.interimTile = tile;\n            newTile.refreshInterimChain();\n            this.tileCache.replace(coordKey, newTile);\n        }\n        else {\n            this.tileCache.set(coordKey, newTile);\n        }\n        return newTile;\n    };\n    /**\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n     */\n    VectorTile.prototype.getTileGridForProjection = function (projection) {\n        var code = projection.getCode();\n        var tileGrid = this.tileGrids_[code];\n        if (!tileGrid) {\n            // A tile grid that matches the tile size of the source tile grid is more\n            // likely to have 1:1 relationships between source tiles and rendered tiles.\n            var sourceTileGrid = this.tileGrid;\n            tileGrid = createForProjection(projection, undefined, sourceTileGrid\n                ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom())\n                : undefined);\n            this.tileGrids_[code] = tileGrid;\n        }\n        return tileGrid;\n    };\n    /**\n     * Get the tile pixel ratio for this source.\n     * @param {number} pixelRatio Pixel ratio.\n     * @return {number} Tile pixel ratio.\n     */\n    VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {\n        return pixelRatio;\n    };\n    /**\n     * @param {number} z Z.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     * @return {import(\"../size.js\").Size} Tile size.\n     */\n    VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {\n        var tileGrid = this.getTileGridForProjection(projection);\n        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);\n        return [\n            Math.round(tileSize[0] * pixelRatio),\n            Math.round(tileSize[1] * pixelRatio),\n        ];\n    };\n    /**\n     * Increases the cache size if needed\n     * @param {number} tileCount Minimum number of tiles needed.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    VectorTile.prototype.updateCacheSize = function (tileCount, projection) {\n        _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);\n    };\n    return VectorTile;\n}(UrlTile));\nexport default VectorTile;\n/**\n * Sets the loader for a tile.\n * @param {import(\"../VectorTile.js\").default} tile Vector tile.\n * @param {string} url URL.\n */\nexport function defaultLoadFunction(tile, url) {\n    tile.setLoader(\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import(\"../proj/Projection.js\").default} projection Projection.\n     */\n    function (extent, resolution, projection) {\n        loadFeaturesXhr(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));\n    });\n}\n//# sourceMappingURL=VectorTile.js.map"]},"metadata":{},"sourceType":"module"}