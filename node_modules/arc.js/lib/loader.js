'use strict';

const fs = require('../utils/fs');
const _ = require('lodash');
const specification = require('./specification');
const path = require('path');
const extension = require('./extension');

async function load (apiDir, spec, loaded) {
  // validate user schema
  specification.validateSchema(spec);

  // load disk schema
  const diskSchema = await specification.loadSchema(apiDir, spec);

  // validate user schema content using the real schema
  specification.validateContent(spec, diskSchema);

  return loadSpecs(apiDir, spec, diskSchema, loaded);
}

async function loadSpecs (location, userSpec, loadedSpec, loaded) {
  const existingSpecs = [];

  for (const spec of userSpec) {
    existingSpecs.push(spec.name);

    if (spec.type === 'module') {
      const loadedModule = fs.loadModules(path.join(location, spec.name), true);
      loaded[loadedModule.name] = loadedModule.data;
    }
    else if (spec.type === 'component') {
      const loadedComponent = _.find(loadedSpec, { name: spec.name });
      if (!loaded[spec.name]) {
        loaded[spec.name] = {};
      }
      loadComponent(location, spec, loadedComponent, loaded[spec.name]);
      await extension.execComponent({
        location,
        component: loaded[spec.name],
        componentName: spec.name
      });
    }
  }

  for (const spec of loadedSpec) {
    if (_.includes(existingSpecs, spec.name)) {
      continue;
    }

    existingSpecs.push(spec.name);
    if (spec.type === 'module') {
      const loadedModule = fs.loadModules(path.join(location, spec.name), true);
      loaded[loadedModule.name] = loadedModule.data;
    }
    else if (spec.type === 'component') {
      if (!loaded[spec.name]) {
        loaded[spec.name] = {};
      }
      loadComponent(location, spec, null, loaded[spec.name]);
      await extension.execComponent({
        location,
        component: loaded[spec.name],
        componentName: spec.name
      });
    }
  }

  return loaded;
}

function loadComponent (
  location,
  userComponent,
  loadedComponent,
  loadedModules
) {
  const validationArray = [];

  _.forEach(userComponent.modules, (moduleToLoad) => {
    _loadModules(
      validationArray,
      loadedModules,
      moduleToLoad,
      location,
      userComponent.name,
      moduleToLoad.name
    );
  });

  if (loadedComponent) {
    _.forEach(loadedComponent.modules, (moduleToLoad) => {
      _loadModules(
        validationArray,
        loadedModules,
        moduleToLoad,
        location,
        loadedComponent.name,
        moduleToLoad.name
      );
    });
  }

  return loadedModules;
}

function _loadModules (
  validationArray,
  loadedModules,
  moduleToLoad,
  ...modulePath
) {
  if (!_.find(validationArray, moduleToLoad.name)) {
    const componentPath = path.join(...modulePath);
    const loadedModule = fs.loadModules(componentPath, true);
    loadedModules[loadedModule.name] = loadedModule.data;
    validationArray.push(loadedModule.name);
  }
}

module.exports = {
  load,
  loadSpecs,
  loadComponent
};
