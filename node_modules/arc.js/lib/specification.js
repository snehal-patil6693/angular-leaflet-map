'use strict';

const Joi = require('joi');
const _ = require('lodash');
const fs = require('../utils/fs');
const error = require('./error');
const path = require('path');

function validateSchema (userSchema) {
  const schema = Joi.array().items({
    name: Joi.string(),
    type: Joi.string().valid('module', 'component'),
    disable: Joi.boolean(),
    modules: Joi.array()
      .items({ name: Joi.string() })
      .when('type', {
        is: 'component',
        then: Joi.optional(),
        otherwise: Joi.forbidden()
      })
  });

  const result = Joi.validate(userSchema, schema);

  if (result.error) {
    result.error.message = error({
      location: 'arc loader - specification schema validator',
      description: result.error.message
    });
    throw result.error;
  }
  else {
    return true;
  }
}

function validateContent (userSchema, loadedSchema) {
  _.forEach(userSchema, (schemaItem) => {

    if (schemaItem.disable) {
      return;
    }

    const existingSchemaItem = _.find(loadedSchema, { name: schemaItem.name });

    if (!existingSchemaItem) {
      // throw error
      throw new Error(`item not found ${schemaItem.name}`);
    }

    if (!_.isEmpty(schemaItem.modules)) {
      if (_.isEmpty(existingSchemaItem.modules)) {
        throw new Error(`${existingSchemaItem.name} does not have modules`);
      }

      _.forEach(schemaItem.modules, (subSchemaItem) => {
        const existingSubSchemaItem = _.find(existingSchemaItem.modules, { name: subSchemaItem.name });

        if (!existingSubSchemaItem) {
          throw new Error(`item not found ${subSchemaItem.name}`);
        }
      });
    }
  });
  return true;
}

async function loadSchema (location, spec) {

  const content = await fs.dirContent(location);

  let schema = [];

  _.forEach(content.files, (file) => {
    const relatedSpec = _.find(spec, { name: file });
    if (!relatedSpec || !relatedSpec.disable) {
      schema.push({ name: file, type: 'module' });
    }
  });

  const promiseArray = [];
  _.forEach(content.folders, (folder) => {
    const relatedSpec = _.find(spec, { name: folder });
    if (!relatedSpec || !relatedSpec.disable) {
      promiseArray.push(_componentSchema(location, folder, spec));
    }
  });

  const components = await Promise.all(promiseArray);

  schema = _.union(schema, components);

  return schema;
}

async function _componentSchema (location, folder, spec) {

  const content = await fs.dirContent(path.join(location, folder));

  const foundModules = _.filter(content.files, (c) => {
    const relatedSpec = _.find(spec, { name: folder });
    if (!relatedSpec || !relatedSpec.disable) {
      return c;
    }
  });

  const component = {
    name: folder,
    type: 'component',
    modules: []
  };

  component.modules = _.map(foundModules, (file) => {
    return { name: file };
  });

  return component;
}

module.exports = {
  loadSchema,
  validateSchema,
  validateContent
};
