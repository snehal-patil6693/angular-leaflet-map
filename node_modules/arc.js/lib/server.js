'use strict';

const fs = require('../utils/fs');
const log = require('../utils/log');
const config = require('./config');
const paths = require('../text/paths.json');
const loader = require('./loader');
const error = require('./error');
const arcConfig = require('./arcjsConfig');
const _ = require('lodash');
const env = require('./env');

const extension = require('./extension');

/**
 * main server class contains
 * all the arc functionalities
 * @class ArcJs
 */
class ArcJs {
  constructor (appDir) {
    this.error = error;
    this.fs = fs;
    this.log = log;
    this.ENV = env();
    this.paths = this._resolvePaths(paths, appDir);
    this.paths.app = appDir;
  }

  async init () {
    this.ArcJsConfig = await arcConfig(this.paths.arcJsConfig);
    this.config = await config.load(this.paths.config, this.ENV);
    await extension.load({
      location: this.paths.extensions,
      exts: _.get(this.ArcJsConfig, 'extensions') || [],
      deps: {
        config: this.config,
        log: this.log
      }
    });
  }

  _resolvePaths (pathsList, prefix) {
    const resolved = {};

    this.fs.resolvePaths(pathsList, prefix, (resolvedPath, key) => {
      resolved[key] = resolvedPath;
    });

    return resolved;
  }

  async loadArc (location, spec, loaded) {
    if (typeof spec === 'string') {
      spec = await this.fs.loadModules(spec).data;
    }
    return loader.load(location, spec, loaded);
  }

  async before (args) {
    await extension.execBefore(args);
  }

  async component (args) {
    await extension.execComponent(args);
  }

  async after (args) {
    await extension.execAfter(args);
  }

  async bootstrap () {

    if (!await fs.canRead(this.paths.bootstrap)) {
      return;
    }

    const bs = await fs.loadModules(this.paths.bootstrap, true);
    if (bs) {
      await bs.data();
    }
  }

}

module.exports = ArcJs;
